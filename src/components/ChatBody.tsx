
import { forwardRef, useEffect, useRef, useState, useCallback } from "react";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import { RotateCcw, Copy, Pencil } from "lucide-react";
import { CodeBlock } from "./CodeBlock";
import { CodeBlockLoader } from "./CodeBlockLoader";
import { ThinkingIndicator } from "./ThinkingIndicator";
import { Button } from "@/components/ui/button";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faUser, faRobot } from "@fortawesome/free-solid-svg-icons";
import { useTheme } from "@/hooks/useTheme";
import { toast } from "sonner";
import { WeatherWidget } from "@/components/WeatherWidget";
import { RSSWidget } from "@/components/RSSWidget";
import { ChatService, ChatMessage } from "@/services/chatService";
import { Storage } from "@/utils/storage";
import { saveWelcomeMessage } from "@/utils/indexedDb";
import { getPrimaryApiKey } from "@/utils/api";

const getUserName = () => {
  try {
    const profileId = localStorage.getItem('vivica-current-profile') || '';
    const profileMem = profileId
      ? JSON.parse(localStorage.getItem(`vivica-memory-profile-${profileId}`) || 'null')
      : null;
    const globalMem = JSON.parse(localStorage.getItem('vivica-memory-global') || 'null');
    const mem = profileMem || globalMem || {};
    return mem.identity?.name || 'User';
  } catch {
    return 'User';
  }
};

const getProfileName = (id?: string) => {
  try {
    const list: { id: string; name: string }[] = JSON.parse(localStorage.getItem('vivica-profiles') || '[]');
    const pid = id || localStorage.getItem('vivica-current-profile');
    return list.find((p) => p.id === pid)?.name || 'Vivica';
  } catch {
    return 'Vivica';
  }
};

interface Message {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  timestamp: Date;
  failed?: boolean;
  isCodeResponse?: boolean;
  codeLoading?: boolean;
  /** Which profile produced this message (for badges) */
  profileId?: string;
  pinned?: boolean;
}

interface Conversation {
  id: string;
  title: string;
  messages: Message[];
  lastMessage?: string;
  timestamp: Date;
  /** True if the title was generated by Vivica */
  autoTitled?: boolean;
}

interface ProfileBrief {
  isVivica?: boolean;
  model: string;
  systemPrompt: string;
  temperature: number;
}

interface ChatBodyProps {
  conversation: Conversation | null;
  currentProfile?: { id: string } | null;
  isTyping: boolean;
  onRetryMessage?: (messageId: string) => void;
  onRegenerateMessage?: (messageId: string) => void;
  onEditMessage?: (message: Message) => void;
  onSendMessage: (content: string) => void;
  onNewChat: () => void;
  onPinMessage?: (id: string, pinned: boolean) => void;
  onSaveToMemory?: (content: string, scope: 'global' | 'profile') => void;
  onSummarize?: (content: string) => void;
}

export const ChatBody = forwardRef<HTMLDivElement, ChatBodyProps>(
  ({ conversation, currentProfile, isTyping, onRetryMessage, onRegenerateMessage, onEditMessage, onSendMessage, onNewChat, onPinMessage, onSaveToMemory, onSummarize }, ref) => {
    const messagesEndRef = useRef<HTMLDivElement>(null);
    const { color, variant } = useTheme();
    const logoSrc = `/logo-${color}${variant}.png`;
    const [welcomeMsg, setWelcomeMsg] = useState('');
    const [welcomeError, setWelcomeError] = useState(false);
    const [animateWelcome, setAnimateWelcome] = useState(false);
    const lastWelcomeRef = useRef('');
    const lastMessage = conversation?.messages?.[conversation.messages.length - 1];
    const showThinking = isTyping && !(lastMessage?.isCodeResponse);

    const fetchWelcome = useCallback(async () => {
      if (!conversation || conversation.messages.length) return;

      setWelcomeError(false);

      // Use a short-lived cache to avoid spamming the LLM on focus/visibility changes
      const CACHE_KEY = 'vivica-welcome-cache';
      const CACHE_TTL_MS = 15 * 60 * 1000; // 15 minutes
      try {
        const cached = JSON.parse(localStorage.getItem(CACHE_KEY) || 'null') as { text: string; ts: number } | null;
        if (cached && Date.now() - cached.ts < CACHE_TTL_MS) {
          lastWelcomeRef.current = cached.text;
          setWelcomeMsg(cached.text);
          setAnimateWelcome(true);
          return;
        }
      } catch { /* ignore */ }

      const getFresh = async () => {
        const raw = localStorage.getItem('vivica-profiles') || '[]';
        const profiles = JSON.parse(raw) as ProfileBrief[];
        const vivica = profiles.find(p => p.isVivica) || Storage.createVivicaProfile();

        const apiKey = getPrimaryApiKey();
        if (!apiKey) {
          toast.error('Please set your OpenRouter API key in Settings.');
          return;
        }

        const chatService = new ChatService(apiKey);
        // If rate-limited recently, avoid another welcome call
        if (ChatService.isPenalized()) {
          const cached = JSON.parse(localStorage.getItem('vivica-welcome-cache') || 'null');
          if (cached?.text) {
            lastWelcomeRef.current = cached.text;
            setWelcomeMsg(cached.text);
            setAnimateWelcome(true);
            return;
          }
        }
        const systemPrompt = vivica.systemPrompt;
        const prompt = `${systemPrompt}\n\nVivica, write a short, snarky, surprising welcome message (max 120 characters). Speak in your own voice. Never mention AI or 'assistant.' Only return the message text—no extra formatting, no meta statements, no greetings like 'Welcome.' Do not repeat the previous message.`;

        const reqMessages: ChatMessage[] = [{ role: 'system', content: prompt }];
        const res = await chatService.sendMessage({
          model: vivica.model,
          messages: reqMessages,
          temperature: vivica.temperature,
          max_tokens: 60,
        });
        const data = await res.json();
        return data.choices?.[0]?.message?.content?.trim();
      };

      try {
        const text = await getFresh();
        if (!text) return;
        let tmp = text;
        // If the LLM repeats the exact same message or exceeds the cap, retry once at most
        if (tmp && (tmp === lastWelcomeRef.current || tmp.length > 120)) {
          const retry = await getFresh();
          if (retry) tmp = retry;
        }

        if (tmp && tmp.length <= 120) {
          lastWelcomeRef.current = tmp;
          setWelcomeMsg(tmp);
          saveWelcomeMessage(tmp);
          // Save to localStorage cache for TTL gating
          try { localStorage.setItem(CACHE_KEY, JSON.stringify({ text: tmp, ts: Date.now() })); } catch {}
          setAnimateWelcome(true);
          return;
        }

        throw new Error('empty');
      } catch {
        setWelcomeError(true);
        setWelcomeMsg('Vivica is brooding. Try again.');
      }
    }, [conversation]);

    const scrollToBottom = () => {
      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    };

    // Auto-scroll only when the user is already near the bottom. This allows
    // scrolling up to read older messages without being snapped back down.
    useEffect(() => {
      const el = (ref as React.RefObject<HTMLDivElement>)?.current;
      if (!el) return;
      const atBottom =
        el.scrollHeight - el.scrollTop <= el.clientHeight + 16;
      if (atBottom) scrollToBottom();
    }, [conversation?.messages, isTyping, ref]);

    // Fetch a dynamic welcome message from the LLM whenever the welcome screen is visible
    useEffect(() => {
      if (!conversation || conversation.messages.length) return;

      fetchWelcome();

      const onFocus = () => fetchWelcome();
      const onVisibility = () => {
        if (document.visibilityState === 'visible') fetchWelcome();
      };
      window.addEventListener('focus', onFocus);
      document.addEventListener('visibilitychange', onVisibility);

      return () => {
        window.removeEventListener('focus', onFocus);
        document.removeEventListener('visibilitychange', onVisibility);
      };
    }, [conversation, fetchWelcome]);

    useEffect(() => {
      if (!welcomeMsg) return;
      setAnimateWelcome(true);
      const t = setTimeout(() => setAnimateWelcome(false), 400);
      return () => clearTimeout(t);
    }, [welcomeMsg]);


    const handleCopyMessage = (content: string) => {
      navigator.clipboard.writeText(content);
      toast.success("Message copied to clipboard");
    };

    const formatTimestamp = (timestamp: Date) => {
      return timestamp.toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit'
      });
    };


    return (
      <div
        ref={ref}
        className="flex-1 overflow-y-auto p-4 space-y-6 relative"
      >
        {!conversation?.messages.length ? (
          // Empty state
          <div className="flex flex-col items-center justify-center h-full text-center space-y-8 max-w-2xl mx-auto -mt-8">
            <div className="space-y-4">
              <img src={logoSrc} alt="Vivica" className="w-40 h-40 mx-auto" onError={(e) => { (e.target as HTMLImageElement).src = `/logo-default${variant}.png`; }} />
              <h2 className="text-3xl font-bold">Welcome to Vivica</h2>
              <p
                onClick={() => welcomeError && fetchWelcome()}
                className={`text-lg text-muted-foreground ${animateWelcome ? 'fade-in slide-up' : ''} ${welcomeError ? 'cursor-pointer' : ''}`}
              >
                {welcomeMsg}
              </p>
            </div>

            <div className="grid grid-cols-1 gap-4 w-full max-w-md">
              <WeatherWidget />
              <RSSWidget onSendMessage={onSendMessage} onNewChat={onNewChat} />
            </div>
          </div>
        ) : (
          // Messages
          <div className="space-y-4 sm:space-y-6 max-w-full sm:max-w-4xl mx-auto overflow-x-hidden">
            {conversation.messages.map((message, index) => (
              <div
                key={message.id}
                className={`flex flex-col ${
                  message.role === 'user' ? 'items-end' : 'items-start'
                } mb-2 ${message.isCodeResponse ? '' : 'slide-up'} group`}
              >
                <div
                  className={`flex items-center gap-2 mb-0.5 ${
                    message.role === 'user' ? 'flex-row-reverse' : ''
                  }`}
                >
                  {message.role === 'assistant' ? (
                    <>
                      <FontAwesomeIcon icon={faRobot} className="w-4 h-4" />
                      <span className="font-medium text-xs text-muted-foreground">
                        {getProfileName(message.profileId)}
                      </span>
                    </>
                  ) : (
                    <>
                      <FontAwesomeIcon icon={faUser} className="w-4 h-4" />
                      <span className="font-medium text-xs text-muted-foreground">
                        {getUserName()}
                      </span>
                    </>
                  )}
                </div>

                  
                  <div
                    className={`message-bubble ${message.role} ${
                      message.isCodeResponse ? 'code-bubble' : ''
                    } ${
                      message.failed ? 'border-accent/50 bg-accent/10' : ''
                    } px-3 py-2 rounded-[2rem] max-w-[95vw] sm:max-w-2xl break-words ${
                      message.role === 'user'
                        ? 'rounded-br-none ml-6 mr-6'
                        : 'rounded-bl-none mr-6 ml-6'
                    } ${
                      index === conversation?.messages.length - 1 ? 'glow-once' : ''
                    }`}
                  >
                  <div className="prose break-words max-w-none text-sm leading-snug">
                      <ReactMarkdown
                        remarkPlugins={[remarkGfm]}
                        components={{
                          code({ node, inline, className, children, ...props }) {
                            if (inline) {
                              return (
                                <code className="inline-code" {...props}>{children}</code>
                              );
                            }
                            
                            // Check if we're streaming and this is a partial code block
                            const isStreaming = isTyping && index === conversation.messages.length - 1;
                            const isPartialCode = typeof children === 'string' && 
                              (children.trim() === '' || 
                               !children.trim().endsWith('```'));
                            
                            if (isStreaming && isPartialCode) {
                              return <CodeBlockLoader />;
                            }
                            
                            return (
                              <CodeBlock className={className}>{children}</CodeBlock>
                            );
                          }
                        }}
                      >
                        {
                          // Avoid rendering raw objects like [object Object]
                          // If the message content isn't a string, log it and
                          // fall back to JSON so the UI stays readable
                          typeof message.content === 'string'
                            ? message.content
                            : (console.log('Non-string message', message.content),
                              JSON.stringify(message.content))
                        }
                      </ReactMarkdown>
                    {message.codeLoading && <CodeBlockLoader />}
                  </div>
                  
                  <div className="flex items-center justify-between mt-2 gap-2">
                    <div className={`flex items-center gap-2 text-xs opacity-60 ${
                      message.role === 'user' ? 'text-right' : 'text-left'
                    }`}>
                      {message.pinned && (
                        <span className="inline-block w-2 h-2 rounded-full bg-yellow-500/80" title="Pinned" />
                      )}
                      {message.isCodeResponse && (
                        <span className="inline-block w-2 h-2 rounded-full bg-blue-500/70" 
                              title="Code response" />
                      )}
                      {message.failed && (
                        <span className="text-red-500/80" title="Failed message">⚠️</span>
                      )}
                      {formatTimestamp(message.timestamp)}
                        {message.profileId !== currentProfile?.id && (
                          <span className="px-1 py-0.5 rounded text-xxs bg-muted/50">
                            {getProfileName(message.profileId)}
                          </span>
                        )}
                      </div>
                      
                      <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() =>
                            handleCopyMessage(
                              typeof message.content === 'string'
                                ? message.content
                                : JSON.stringify(message.content)
                            )
                          }
                          className="h-6 w-6 p-0"
                        >
                          <Copy className="w-3 h-3" />
                        </Button>

                        {/* Pin toggle */}
                        {onPinMessage && (
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => onPinMessage(message.id, !message.pinned)}
                            className="h-6 w-6 p-0"
                            title={message.pinned ? 'Unpin' : 'Pin'}
                          >
                            <span className="w-3 h-3">📌</span>
                          </Button>
                        )}

                        {/* Save to memory */}
                        {onSaveToMemory && (
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => onSaveToMemory(
                              typeof message.content === 'string' ? message.content : JSON.stringify(message.content),
                              'profile'
                            )}
                            className="h-6 w-6 p-0"
                            title="Save to Memory"
                          >
                            <span className="w-3 h-3">🧠</span>
                          </Button>
                        )}

                        {/* Summarize this snippet */}
                        {onSummarize && (
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => onSummarize(
                              typeof message.content === 'string' ? message.content : JSON.stringify(message.content)
                            )}
                            className="h-6 w-6 p-0"
                            title="Summarize this"
                          >
                            <span className="w-3 h-3">✨</span>
                          </Button>
                        )}

                        {message.role === 'user' && onEditMessage && (
                          (() => {
                            const lastIndex = conversation?.messages.length ? conversation.messages.length - 1 : -1;
                            const isLastUser =
                              (index === lastIndex && message.role === 'user') ||
                              (index === lastIndex - 1 && conversation?.messages[lastIndex].role === 'assistant');
                            return isLastUser ? (
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => onEditMessage(message)}
                                className="h-6 w-6 p-0"
                              >
                                <Pencil className="w-3 h-3" />
                              </Button>
                            ) : null;
                          })()
                        )}

                        {message.role === 'assistant' && index === conversation?.messages.length - 1 && !message.failed && onRegenerateMessage && (
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => onRegenerateMessage(message.id)}
                            className="h-6 w-6 p-0"
                          >
                            <RotateCcw className="w-3 h-3" />
                          </Button>
                        )}

                        {message.failed && onRetryMessage && (
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => onRetryMessage(message.id)}
                            className="h-6 w-6 p-0 text-accent hover:text-accent/90"
                          >
                            <RotateCcw className="w-3 h-3" />
                          </Button>
                        )}
                      </div>
                    </div>
                  </div>
                  
              </div>
            ))}


            <div ref={messagesEndRef} />
            {showThinking && (
              <div className="px-6 pt-2">
                <ThinkingIndicator />
              </div>
            )}
          </div>
        )}
      </div>
    );
  }
);

ChatBody.displayName = "ChatBody";
