
import { forwardRef, useEffect, useRef, useState, useCallback } from "react";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import { RotateCcw, Copy, Pencil } from "lucide-react";
import { CodeBlock } from "./CodeBlock";
import { CodeBlockLoader } from "./CodeBlockLoader";
import { ThinkingIndicator } from "./ThinkingIndicator";
import { Button } from "@/components/ui/button";
import { FaUser, FaRobot } from "react-icons/fa";
import { useTheme } from "@/hooks/useTheme";
import { toast } from "sonner";
import { WeatherWidget } from "@/components/WeatherWidget";
import { RSSWidget } from "@/components/RSSWidget";
import { ChatService, ChatMessage } from "@/services/chatService";
import { Storage } from "@/utils/storage";
import { saveWelcomeMessage } from "@/utils/indexedDb";

const getUserName = () => {
  try {
    const profileId = localStorage.getItem('vivica-current-profile') || '';
    const profileMem = profileId
      ? JSON.parse(localStorage.getItem(`vivica-memory-profile-${profileId}`) || 'null')
      : null;
    const globalMem = JSON.parse(localStorage.getItem('vivica-memory-global') || 'null');
    const mem = profileMem || globalMem || {};
    return mem.identity?.name || 'User';
  } catch {
    return 'User';
  }
};

const getProfileName = (id?: string) => {
  try {
    const list: { id: string; name: string }[] = JSON.parse(localStorage.getItem('vivica-profiles') || '[]');
    const pid = id || localStorage.getItem('vivica-current-profile');
    return list.find((p) => p.id === pid)?.name || 'Vivica';
  } catch {
    return 'Vivica';
  }
};

interface Message {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  timestamp: Date;
  failed?: boolean;
  isCodeResponse?: boolean;
  codeLoading?: boolean;
}

interface Conversation {
  id: string;
  title: string;
  messages: Message[];
  lastMessage?: string;
  timestamp: Date;
  /** True if the title was generated by Vivica */
  autoTitled?: boolean;
}

interface ProfileBrief {
  isVivica?: boolean;
  model: string;
  systemPrompt: string;
  temperature: number;
}

interface ChatBodyProps {
  conversation: Conversation | null;
  currentProfile?: { id: string } | null;
  isTyping: boolean;
  onRetryMessage?: (messageId: string) => void;
  onRegenerateMessage?: (messageId: string) => void;
  onEditMessage?: (message: Message) => void;
  onSendMessage: (content: string) => void;
  onNewChat: () => void;
}

export const ChatBody = forwardRef<HTMLDivElement, ChatBodyProps>(
  ({ conversation, currentProfile, isTyping, onRetryMessage, onRegenerateMessage, onEditMessage, onSendMessage, onNewChat }, ref) => {
    const messagesEndRef = useRef<HTMLDivElement>(null);
    const { color, variant } = useTheme();
    const logoSrc = `/logo-${color}${variant}.png`;
    const [welcomeMsg, setWelcomeMsg] = useState('');
    const [welcomeError, setWelcomeError] = useState(false);
    const [animateWelcome, setAnimateWelcome] = useState(false);
    const lastWelcomeRef = useRef('');
    const lastMessage = conversation?.messages?.[conversation.messages.length - 1];
    const showThinking = isTyping && !(lastMessage?.isCodeResponse);

    const fetchWelcome = useCallback(async () => {
      if (!conversation || conversation.messages.length) return;

      setWelcomeError(false);

      const getFresh = async () => {
        const raw = localStorage.getItem('vivica-profiles') || '[]';
        const profiles = JSON.parse(raw) as ProfileBrief[];
        const vivica = profiles.find(p => p.isVivica) || Storage.createVivicaProfile();

        const apiKey = localStorage.getItem('openrouter-api-key');
        if (!apiKey) throw new Error('missing api key');

        const chatService = new ChatService(apiKey);
        const systemPrompt = vivica.systemPrompt;
        const prompt = `${systemPrompt}\n\nVivica, write a short, snarky, surprising welcome message (max 120 characters). Speak in your own voice. Never mention AI or 'assistant.' Only return the message text—no extra formatting, no meta statements, no greetings like 'Welcome.' Do not repeat the previous message.`;

        const reqMessages: ChatMessage[] = [{ role: 'system', content: prompt }];
        const res = await chatService.sendMessage({
          model: vivica.model,
          messages: reqMessages,
          temperature: vivica.temperature,
          max_tokens: 60,
        });
        const data = await res.json();
        return data.choices?.[0]?.message?.content?.trim();
      };

      try {
        let text = await getFresh();
        let attempts = 0;
        while (
          text &&
          (text === lastWelcomeRef.current || text.length > 120) &&
          attempts < 2
        ) {
          text = await getFresh();
          attempts++;
        }

        if (text && text.length <= 120) {
          lastWelcomeRef.current = text;
          setWelcomeMsg(text);
          saveWelcomeMessage(text);
          setAnimateWelcome(true);
          return;
        }

        throw new Error('empty');
      } catch {
        setWelcomeError(true);
        setWelcomeMsg('Vivica is brooding. Try again.');
      }
    }, [conversation?.id, conversation?.messages.length]);

    const scrollToBottom = () => {
      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    };

    // Auto-scroll only when the user is already near the bottom. This allows
    // scrolling up to read older messages without being snapped back down.
    useEffect(() => {
      const el = (ref as React.RefObject<HTMLDivElement>)?.current;
      if (!el) return;
      const atBottom =
        el.scrollHeight - el.scrollTop <= el.clientHeight + 16;
      if (atBottom) scrollToBottom();
    }, [conversation?.messages, isTyping]);

    // Fetch a dynamic welcome message from the LLM whenever the welcome screen is visible
    useEffect(() => {
      if (!conversation || conversation.messages.length) return;

      fetchWelcome();

      const onFocus = () => fetchWelcome();
      const onVisibility = () => {
        if (document.visibilityState === 'visible') fetchWelcome();
      };
      window.addEventListener('focus', onFocus);
      document.addEventListener('visibilitychange', onVisibility);

      return () => {
        window.removeEventListener('focus', onFocus);
        document.removeEventListener('visibilitychange', onVisibility);
      };
    }, [conversation?.id, conversation?.messages.length, fetchWelcome]);

    useEffect(() => {
      if (!welcomeMsg) return;
      setAnimateWelcome(true);
      const t = setTimeout(() => setAnimateWelcome(false), 400);
      return () => clearTimeout(t);
    }, [welcomeMsg]);


    const handleCopyMessage = (content: string) => {
      navigator.clipboard.writeText(content);
      toast.success("Message copied to clipboard");
    };

    const formatTimestamp = (timestamp: Date) => {
      return timestamp.toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit'
      });
    };


    return (
      <div
        ref={ref}
        className="flex-1 overflow-y-auto p-4 space-y-6 relative"
      >
        {!conversation?.messages.length ? (
          // Empty state
          <div className="flex flex-col items-center justify-center h-full text-center space-y-8 max-w-2xl mx-auto -mt-8">
            <div className="space-y-4">
              <img src={logoSrc} alt="Vivica" className="w-40 h-40 mx-auto" />
              <h2 className="text-3xl font-bold">Welcome to Vivica</h2>
              <p
                onClick={() => welcomeError && fetchWelcome()}
                className={`text-lg text-muted-foreground ${animateWelcome ? 'fade-in slide-up' : ''} ${welcomeError ? 'cursor-pointer' : ''}`}
              >
                {welcomeMsg}
              </p>
            </div>

            <div className="grid grid-cols-1 gap-4 w-full max-w-md">
              <WeatherWidget />
              <RSSWidget onSendMessage={onSendMessage} onNewChat={onNewChat} />
            </div>
          </div>
        ) : (
          // Messages
          <div className="space-y-4 sm:space-y-6 max-w-full sm:max-w-4xl mx-auto overflow-x-hidden">
            {conversation.messages.map((message, index) => (
              <div
                key={message.id}
                className={`flex flex-col ${
                  message.role === 'user' ? 'items-end' : 'items-start'
                } mb-2 ${message.isCodeResponse ? '' : 'slide-up'} group`}
              >
                <div
                  className={`flex items-center gap-2 mb-0.5 ${
                    message.role === 'user' ? 'flex-row-reverse' : ''
                  }`}
                >
                  {message.role === 'assistant' ? (
                    <>
                      <FaRobot className="w-4 h-4" />
                      <span className="font-medium text-xs text-muted-foreground">
                        {getProfileName(message.profileId)}
                      </span>
                    </>
                  ) : (
                    <>
                      <FaUser className="w-4 h-4" />
                      <span className="font-medium text-xs text-muted-foreground">
                        {getUserName()}
                      </span>
                    </>
                  )}
                </div>

                  
                  <div
                    className={`message-bubble ${message.role} ${
                      message.isCodeResponse ? 'code-bubble' : ''
                    } ${
                      message.failed ? 'border-accent/50 bg-accent/10' : ''
                    } px-3 py-2 rounded-[2rem] max-w-[95vw] sm:max-w-2xl break-words ${
                      message.role === 'user'
                        ? 'rounded-br-none ml-6 mr-2000'
                        : 'rounded-bl-none mr-6 ml-6'
                    } ${
                      index === conversation?.messages.length - 1 ? 'glow-once' : ''
                    }`}
                  >
                    <div className="prose break-words max-w-none text-sm leading-snug">
                      <ReactMarkdown
                        remarkPlugins={[remarkGfm]}
                        components={{
                          code({ node, inline, className, children, ...props }) {
                            if (inline) {
                              return (
                                <code className="inline-code" {...props}>{children}</code>
                              );
                            }
                            
                            // Check if we're streaming and this is a partial code block
                            const isStreaming = isTyping && index === conversation.messages.length - 1;
                            const isPartialCode = typeof children === 'string' && 
                              (children.trim() === '' || 
                               !children.trim().endsWith('```'));
                            
                            if (isStreaming && isPartialCode) {
                              return <CodeBlockLoader />;
                            }
                            
                            return (
                              <CodeBlock className={className}>{children}</CodeBlock>
                            );
                          }
                        }}
                      >
                        {
                          // Avoid rendering raw objects like [object Object]
                          // If the message content isn't a string, log it and
                          // fall back to JSON so the UI stays readable
                          typeof message.content === 'string'
                            ? message.content
                            : (console.log('Non-string message', message.content),
                              JSON.stringify(message.content))
                        }
                      </ReactMarkdown>
                      {message.codeLoading && <CodeBlockLoader />}
                    </div>
                    
                    <div className="flex items-center justify-between mt-2 gap-2">
                      <div className={`flex items-center gap-2 text-xs opacity-60 ${
                        message.role === 'user' ? 'text-right' : 'text-left'
                      }`}>
                        {message.isCodeResponse && (
                          <span className="inline-block w-2 h-2 rounded-full bg-blue-500/70" 
                                title="Code response" />
                        )}
                        {message.failed && (
                          <span className="text-red-500/80" title="Failed message">⚠️</span>
                        )}
                        {formatTimestamp(message.timestamp)}
                        {message.profileId !== currentProfile?.id && (
                          <span className="px-1 py-0.5 rounded text-xxs bg-muted/50">
                            {getProfileName(message.profileId)}
                          </span>
                        )}
                      </div>
                      
                      <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() =>
                            handleCopyMessage(
                              typeof message.content === 'string'
                                ? message.content
                                : JSON.stringify(message.content)
                            )
                          }
                          className="h-6 w-6 p-0"
                        >
                          <Copy className="w-3 h-3" />
                        </Button>

                        {message.role === 'user' && onEditMessage && (
                          (() => {
                            const lastIndex = conversation?.messages.length ? conversation.messages.length - 1 : -1;
                            const isLastUser =
                              (index === lastIndex && message.role === 'user') ||
                              (index === lastIndex - 1 && conversation?.messages[lastIndex].role === 'assistant');
                            return isLastUser ? (
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => onEditMessage(message)}
                                className="h-6 w-6 p-0"
                              >
                                <Pencil className="w-3 h-3" />
                              </Button>
                            ) : null;
                          })()
                        )}

                        {message.role === 'assistant' && onRegenerateMessage && (
                          index === conversation?.messages.length - 1 ? (
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={() => onRegenerateMessage(message.id)}
                              className="h-6 w-6 p-0"
                            >
                              <RotateCcw className="w-3 h-3" />
                            </Button>
                          ) : null
                        )}

                        {message.failed && onRetryMessage && (
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => onRetryMessage(message.id)}
                            className="h-6 w-6 p-0 text-accent hover:text-accent/90"
                          >
                            <RotateCcw className="w-3 h-3" />
                          </Button>
                        )}
                      </div>
                    </div>
                  </div>
                  
              </div>
            ))}


            <div ref={messagesEndRef} />
            {showThinking && (
              <div className="px-6 pt-2">
                <ThinkingIndicator />
              </div>
            )}
          </div>
        )}
      </div>
    );
  }
);

ChatBody.displayName = "ChatBody";
